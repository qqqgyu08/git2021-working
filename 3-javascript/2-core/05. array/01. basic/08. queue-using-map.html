<html>

<body>
  <script>
    // 데이터를 순차적으로 밀어넣고, 들어간 순서대로 꺼내야 함

    // 큐(queue): lIFO(Last In First Out)
    // 큐에 요소 추가 : enqueue
    // 큐에 요소 추출 : dequeue

    // ["hong", "john", "donald", "kim", "lee"]

    // key-value 형태의 자료 구조, key를 문자말고 다른 것 가능
    // 연관 배열(associative array)
    let queue = new Map();
    let head = 0; // 가장 앞쪽 key를 저장하는 변수
    let tail = 0; // 가장 뒤쪽 key를 저장하는 변수

    // queue에 요소(item) 추가(enqueue), tail위치에 넣음
    // object의 tail값의 속성을 만듦 "0", "1", "2"
    queue.set[tail++, "hong"]; // 맵.set(키, 값)
    console.log(queue);
    queue.set[tail++, "john"];
    console.log(queue);
    queue.set[tail++, "donald"];
    console.log(queue);
    queue.set[tail++, "kim"];
    console.log(queue);
    queue.set[tail++, "lee"];
    console.log(queue);


    // queue에서 요소 꺼내기(dequeue), head위치에서 꺼내고 속성 삭제
    console.log(queue.get(head)); //map.get(key) 0, hong
    delete queue(head); // 0, queue.delete(0)
    console.log(queue);

    console.log(queue.get(head)); //map.get(key) 0, hong
    delete queue(head); // 1, queue.delete(1)
    console.log(queue);

    console.log(queue.get(head)); //map.get(key) 0, hong
    delete queue(head); // 2, queue.delete(2)
    console.log(queue);

    console.log(queue.get(head)); //map.get(key) 0, hong
    delete queue(head); // 3, queue.delete(3)
    console.log(queue);

    console.log(queue.get(head)); //map.get(key) 0, hong
    delete queue(head); // 4, queue.delete(4)
    console.log(queue);

    // 내부적으로 key가 숫자로 변환 가능하니
    // 정렬 알고리즘이 실행될까?
    // 속성을 반복해서 탐색할떄 for-in





  </script>
</body>

</html>